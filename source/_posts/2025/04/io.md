---
title: IO
date: 2025-04-13 17:30:35
tags:
---

IO, 全称Input/Output，是信息处理系统与外部世界进行通信的过程[^1]。

## 概念

阻塞/非阻塞与同步/异步是两组不同视角的概念，既有关联，又不完全一样。

+ 阻塞/非阻塞：阻塞指的是在资源（数据、锁等）未就绪时，当前执行单元（进程、线程）进入休眠状态（Sleeping State）[^2]，直到资源就绪后，操作系统会唤醒当前执行单元继续往下执行。非阻塞是即使在资源未就绪的时候，执行单元也不会进入休眠状态，因此可以执行其他任务，具体怎么实现的后面会解释。

思考：Java的线程在等待IO时，是什么状态？

+ 同步/异步：同步/异步是和控制权相关的概念，同步就是面向过程，按代码顺序执行，控制权一直在当前函数中。异步则是面向事件，函数内部分代码在事件发生之后才执行，执行这部分代码的时候，控制权在外边容器中（如Event Loop、 操作系统等），通常由回调函数实现。

所以，同步的代码可以是阻塞的也可以是非阻塞的，但是异步的代码一定是非阻塞的。


## IO的分类

IO主要被分为两个阶段：

1. 数据准备：等待数据从外部设备进入内核缓冲区。
2. 数据复制：数据从内核缓冲区复制到用户空间。

根据上面两个阶段是否阻塞，IO可以分为5种模型。首先根据阶段2是否阻塞可以将IO模型分为同步IO和异步IO，然后同步IO又可以根据阶段1是否阻塞和如何阻塞分为阻塞IO、非阻塞IO、IO多路复用、信号驱动IO等4种模型。 ？？？？

![](image.png)

### 同步IO

+ 阻塞IO：应用程序针对**一个**IO发起操作（read/recv）后，执行单元进入休眠状态，操作系统在完成阶段1和阶段2后唤醒当前执行单元。
+ 非阻塞IO：应用程序针对**一个**IO发起操作（read/recv）后，操作系统根据阶段1的状态返回错误或者进入阶段2，在阶段2中执行单元还是会进入休眠状态。
+ IO多路复用：应用程序针对**多个**IO发起请求（select）后，如果所有被请求的IO都没有就绪，和阻塞IO一样，执行单元进入休眠状态；当其中任意一个IO就绪后，执行单元被唤醒，由应用程序再次发起针对就绪IO的操作（read/recv）。
  + 根据IO被设置为阻塞或者非阻塞模式，就绪的定义不一样，在阻塞模式下，只要有一个字节的数据可以读取，执行单元就被唤醒，后续的read/recv仍就可能被阻塞（阶段1），而在非阻塞（Non-blocking）模式下，select会确保IO完成阶段1后才唤醒执行单元[^3]。

### 异步IO

+ 信号驱动IO：应用程序针对**一个**IO向操作系统注册一个信号处理函数，其后可以执行其他任务，不会进入休眠状态。当该IO完成阶段1后，操作系统会发送SIGIO信号，由应用程序再次发起对这个IO的操作（read/recv）。

+ 异步IO：

如果被请求的所有IO，和阻塞IO一样，执行单元进入休眠状态；当其中任意一个IO完成阶段1后，执行单元被唤醒，



进入阶段2，同样的在阶段2中执行单元还是会进入休眠状态。但是要注意的是，如果IO被设置为阻塞，只要能读到一个字节，就就会进入阶段2，同时，如果IO被设置为非阻塞，



  + 说明：在IO多路复用的描述中，我没有使用“完成阶段1”的描述，而说的是“就绪”。这是因为，根据IO被设置为阻塞或者非阻塞，就绪的





，则执行单元进入休眠状态，当其中任一一个IO完成


### 异步IO



其中3种是同步的，2种是异步的。4种同步的IO模型又可以分为阻塞和非阻塞。

![](image.png)



### 阻塞式IO

### 非阻塞式IO

### IO复用

### 信号驱动IO

### 异步IO

## References

[^1]: https://en.wikipedia.org/wiki/Input/output
[^2]: https://www.baeldung.com/linux/process-states
[^3]: https://stackoverflow.com/questions/18401428/how-to-check-whether-read-system-call-has-read-entire-data-or-not
[^4]: https://pdai.tech/md/java/io/java-io-model.html


https://www.cnblogs.com/loveer/p/11479249.html
